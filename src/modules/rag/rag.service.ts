import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '@common/prisma/prisma.service';
import { VectorSearchService } from './services/vector-search.service';
import { CreateDocumentDto, CreateChunkDto } from './dto';

@Injectable()
export class RagService {
  private readonly logger = new Logger(RagService.name);

  constructor(
    private prisma: PrismaService,
    private vectorSearch: VectorSearchService,
  ) {}

  async createDocument(createDto: CreateDocumentDto) {
    return this.prisma.document.create({
      data: {
        title: createDto.title,
        source: createDto.source,
        sourceUrl: createDto.sourceUrl,
        contentType: createDto.contentType || 'text/plain',
        metadata: createDto.metadata,
      },
    });
  }

  async createChunk(documentId: string, createDto: CreateChunkDto) {
    const document = await this.prisma.document.findUnique({
      where: { id: documentId },
    });

    if (!document) {
      throw new NotFoundException('Document not found');
    }

    // Note: Embedding should be generated by the model service
    // This endpoint receives the pre-computed embedding
    return this.prisma.chunk.create({
      data: {
        documentId,
        content: createDto.content,
        chunkIndex: createDto.chunkIndex,
        metadata: createDto.metadata,
      },
    });
  }

  async getDocuments(source?: string) {
    const where = source ? { source } : {};
    return this.prisma.document.findMany({
      where,
      include: {
        chunks: {
          select: {
            id: true,
            chunkIndex: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async getDocument(id: string) {
    const document = await this.prisma.document.findUnique({
      where: { id },
      include: {
        chunks: {
          orderBy: { chunkIndex: 'asc' },
        },
      },
    });

    if (!document) {
      throw new NotFoundException('Document not found');
    }

    return document;
  }

  async deleteDocument(id: string) {
    await this.prisma.document.delete({
      where: { id },
    });

    return { success: true };
  }

  /**
   * Search for similar chunks using vector similarity
   * The embedding should come from the model service
   */
  async searchSimilarChunks(queryEmbedding: number[], limit = 10, threshold = 0.7) {
    return this.vectorSearch.search(queryEmbedding, limit, threshold);
  }
}

